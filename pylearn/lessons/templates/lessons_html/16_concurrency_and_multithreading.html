<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concurrency and Multithreading in Python</title>
</head>
<body>
    <h1>Concurrency and Multithreading in Python</h1>
    <p>Explore the concepts of concurrency and multithreading in Python, focusing on how they can help manage tasks that may take time to complete.</p>

    <h2>Introduction to Concurrency</h2>
    <p>Concurrency allows multiple tasks to run at the same time but not necessarily in parallel. It's a way of structuring code so that tasks can proceed independently without blocking the execution flow.</p>
    <pre><code>
import threading

def task1():
    print("Task 1 started")
    time.sleep(2)
    print("Task 1 completed")

def task2():
    print("Task 2 started")
    time.sleep(1)
    print("Task 2 completed")

# Running tasks concurrently
thread1 = threading.Thread(target=task1)
thread2 = threading.Thread(target=task2)

thread1.start()
thread2.start()

thread1.join()
thread2.join()
    </code></pre>

    <h3>Creating Threads</h3>
    <p>Threads in Python are created using the <code>threading</code> module. The <code>start()</code> method is used to start a thread, and <code>join()</code> to wait for its completion.</p>

    <h2>Synchronization and Deadlocks</h2>
    <p>Synchronization is a technique used to ensure that only one thread accesses shared resources at a time to avoid conflicts. Deadlocks occur when two or more threads block each other, waiting for resources held by each other.</p>
    <pre><code>
import threading

lock = threading.Lock()

def critical_section():
    with lock:
        print("Thread in critical section")
        time.sleep(1)
        print("Thread leaving critical section")

thread1 = threading.Thread(target=critical_section)
thread2 = threading.Thread(target=critical_section)

thread1.start()
thread2.start()

thread1.join()
thread2.join()
    </code></pre>

    <h3>Deadlock Prevention</h3>
    <p>To prevent deadlocks, use techniques like acquiring locks in the same order by all threads or using timeout when acquiring a lock.</p>

    <h2>Exercises</h2>
    <p>Create a multithreaded program that simulates a simple producer-consumer problem using threading and the <code>queue</code> module.</p>

    <h2>Conclusion</h2>
    <p>This lesson covered concurrency and multithreading in Python. In the next lesson, we'll explore advanced file handling techniques.</p>
</body>
</html>
